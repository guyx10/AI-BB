#!/usr/bin/env python3
import asyncio
import subprocess
import json
import os
import requests
from typing import List, Dict, Any
from datetime import datetime
from urllib.parse import urlparse, parse_qs, urlunparse

class VulnerabilityScanner:
    """Real vulnerability scanning using security tools"""
    
    def __init__(self):
        self.logger = self._create_logger()
    
    def _create_logger(self):
        """Create a simple logger for the vulnerability scanner"""
        class SimpleLogger:
            def info(self, msg):
                print(f"üîç {msg}")
            def debug(self, msg):
                print(f"üîß {msg}")
            def warning(self, msg):
                print(f"‚ö†Ô∏è {msg}")
            def error(self, msg):
                print(f"‚ùå {msg}")
        return SimpleLogger()
    
    async def run_command_with_timeout(self, cmd: str, timeout: int = 60) -> tuple:
        """Run a command with proper timeout handling"""
        try:
            process = await asyncio.create_subprocess_shell(
                cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            # Use asyncio.wait_for for timeout
            try:
                stdout, stderr = await asyncio.wait_for(process.communicate(), timeout=timeout)
                return process.returncode, stdout, stderr
            except asyncio.TimeoutError:
                print(f"         Command timeout: {cmd.split(' ')[0]}")
                process.terminate()
                return -1, None, None
                
        except Exception as e:
            print(f"         Command error: {e}")
            return -1, None, None
    
    async def run_nuclei(self, target: str) -> List[Dict]:
        """Run Nuclei vulnerability scanner"""
        try:
            # Use enhanced nuclei with proper templates
            return await self.run_nuclei_scan_async(target)
            
        except Exception as e:
            print(f"‚ùå Nuclei error for {target}: {e}")
            return []
    
    async def run_nuclei_scan_async(self, target: str) -> List[Dict]:
        """Run comprehensive nuclei scan with proper templates (async version)"""
        try:
            self.logger.info(f"Running Nuclei scan on {target}")
            
            # Get nuclei templates path
            templates_path = self.get_nuclei_templates_path()
            
            # Build nuclei command
            cmd = ['nuclei', '-u', target, '-json', '-silent']
            
            # Add templates if found
            if templates_path:
                cmd.extend(['-t', f'{templates_path}/http/'])
                cmd.extend(['-t', f'{templates_path}/http/exposures/'])
                cmd.extend(['-t', f'{templates_path}/http/vulnerabilities/'])
            else:
                # Use default nuclei behavior if templates not found
                cmd.extend(['-t', 'http/'])
            
            # Add additional options
            cmd.extend([
                '-severity', 'low,medium,high,critical',
                '-rate-limit', '100',
                '-timeout', '10'
            ])
            
            # Add PHP-specific templates if target is PHP
            if self._is_php_target(target) and templates_path:
                cmd.extend(['-t', f'{templates_path}/http/technologies/php.yaml'])
            
            self.logger.debug(f"Running nuclei command: {' '.join(cmd)}")
            
            # Run as subprocess
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await asyncio.wait_for(process.communicate(), timeout=300)
            
            vulnerabilities = []
            if stdout:
                output = stdout.decode()
                for line in output.strip().split('\n'):
                    if line:
                        try:
                            vuln_data = json.loads(line)
                            vulnerability = {
                                'type': vuln_data.get('template-id', 'Unknown'),
                                'url': target,
                                'severity': vuln_data.get('info', {}).get('severity', 'unknown'),
                                'tool': 'nuclei',
                                'evidence': vuln_data.get('matcher-name', ''),
                                'description': vuln_data.get('info', {}).get('description', ''),
                                'timestamp': datetime.now().isoformat()
                            }
                            vulnerabilities.append(vulnerability)
                            self.logger.info(f"Nuclei found: {vulnerability['type']} - {vulnerability['severity']}")
                        except json.JSONDecodeError as e:
                            self.logger.debug(f"Failed to parse nuclei output: {e}")
                            continue
            
            if not vulnerabilities:
                self.logger.info(f"Nuclei found no vulnerabilities for {target}")
            
            return vulnerabilities
            
        except asyncio.TimeoutError:
            self.logger.warning(f"Nuclei scan timed out for {target}")
            return []
        except Exception as e:
            self.logger.error(f"Nuclei scan failed: {str(e)}")
            return []
    
    def get_nuclei_templates_path(self):
        """Get nuclei templates path with fallback"""
        possible_paths = [
            '/root/nuclei-templates',
            '/home/kali/nuclei-templates',
            '/opt/nuclei-templates', 
            '/usr/share/nuclei-templates',
            os.path.expanduser('~/nuclei-templates')
        ]
        
        for path in possible_paths:
            if os.path.exists(path):
                self.logger.info(f"Found nuclei templates at: {path}")
                return path
        
        self.logger.warning("Nuclei templates not found in standard locations")
        return None
    
    def _is_php_target(self, url: str) -> bool:
        """Check if target is PHP-based"""
        try:
            # Get base URL without parameters for testing
            base_url = url.split('?')[0] if '?' in url else url
            response = requests.get(base_url, timeout=5, verify=False)
            content = response.text.lower()
            headers = str(response.headers).lower()
            
            php_indicators = [
                '.php' in url,
                '.php' in content,
                'php' in headers,
                'x-powered-by: php' in headers
            ]
            
            return any(php_indicators)
        except:
            return False
    
    async def run_sqlmap_quick(self, url: str) -> List[Dict]:
        """Run quick sqlmap scan with basic tests"""
        try:
            # Only test if URL has parameters
            if '?' not in url or '=' not in url:
                return []

            print(f"         Testing SQLi on: {url.split('?')[0]}...")

            # Improved sqlmap scan with reasonable timeouts
            param = url.split('?')[1].split('=')[0] if '?' in url else 'id'
            cmd = f"sqlmap -u '{url}' --batch --level=1 --risk=1 --flush-session --time-sec=5 --threads=2"
            
            # Increase timeout to 2 minutes (SQLMap needs time)
            returncode, stdout, stderr = await self.run_command_with_timeout(cmd, timeout=120)

            if returncode == 0 and stdout:
                output = stdout.decode()

                # Parse sqlmap output for vulnerabilities
                if any(indicator in output for indicator in [
                    "sqlmap identified the following injection point",
                    "is vulnerable", 
                    "injection point",
                    "back-end DBMS"
                ]):
                    return [{
                        'type': 'SQL Injection',
                        'url': url,
                        'tool': 'sqlmap',
                        'severity': 'high',
                        'confidence': 'high',
                        'evidence': 'SQL injection confirmed by sqlmap',
                        'parameter': param
                    }]

            return []

        except Exception as e:
            print(f"‚ùå SQLMap error for {url}: {e}")
            return []
    
    async def run_basic_curl_tests(self, url: str) -> List[Dict]:
        """Run basic curl-based security tests"""
        findings = []
        
        try:
            # Test for SQL error messages
            sql_payloads = ["'", "1' OR '1'='1", "1 AND 1=1"]
            for payload in sql_payloads:
                test_url = url.replace('=', f"={payload}", 1)
                cmd = f"curl -s -k '{test_url}' --connect-timeout 5"
                returncode, stdout, stderr = await self.run_command_with_timeout(cmd, timeout=10)
                
                if returncode == 0 and stdout:
                    response = stdout.decode().lower()
                    if any(error in response for error in ['sql', 'mysql', 'database', 'syntax', 'error']):
                        findings.append({
                            'type': 'SQL Injection Potential',
                            'url': url,
                            'tool': 'curl',
                            'severity': 'medium',
                            'confidence': 'low',
                            'evidence': f'SQL error message detected with payload: {payload}',
                            'parameter': url.split('?')[1].split('=')[0] if '?' in url else 'unknown'
                        })
                        break
            
            # Test for basic XSS reflection
            xss_payload = "<script>alert('xss')</script>"
            if '?' in url:
                test_url = url.replace('=', f"={xss_payload}", 1)
                cmd = f"curl -s -k '{test_url}' --connect-timeout 5"
                returncode, stdout, stderr = await self.run_command_with_timeout(cmd, timeout=10)
                
                if returncode == 0 and stdout:
                    response = stdout.decode()
                    if xss_payload in response:
                        findings.append({
                            'type': 'XSS Potential',
                            'url': url,
                            'tool': 'curl',
                            'severity': 'medium',
                            'confidence': 'low',
                            'evidence': 'XSS payload reflected in response',
                            'parameter': url.split('?')[1].split('=')[0] if '?' in url else 'unknown'
                        })
            
            return findings
            
        except Exception as e:
            print(f"‚ùå Curl test error for {url}: {e}")
            return []
    
    async def run_parameter_tests_async(self, target_url, crawled_urls):
        """Run comprehensive parameter-based vulnerability tests (async version)"""
        self.logger.info(f"Running parameter tests on {len(crawled_urls)} URLs")
        vulnerabilities = []
        
        # Test a subset of URLs to avoid timeout
        test_urls = crawled_urls[:20]  # Limit to first 20 URLs
        
        for url in test_urls:
            # Only test URLs with parameters
            if '?' not in url:
                continue
                
            # Extract parameters from URL
            params = self.extract_parameters(url)
            
            for param in params:
                # Test for XSS
                xss_vulns = await self.test_xss_async(url, param)
                vulnerabilities.extend(xss_vulns)
                
                # Test for LFI (only on parameters that suggest file inclusion)
                if any(keyword in param.lower() for keyword in ['file', 'page', 'path', 'load', 'document']):
                    lfi_vulns = await self.test_lfi_async(url, param)
                    vulnerabilities.extend(lfi_vulns)
        
        return vulnerabilities

    def extract_parameters(self, url):
        """Extract parameters from URL"""
        try:
            parsed = urlparse(url)
            params = parse_qs(parsed.query)
            return list(params.keys())
        except Exception as e:
            self.logger.debug(f"Failed to extract parameters from {url}: {e}")
            return []

    async def test_xss_async(self, url, param):
        """Test for XSS vulnerabilities (async version)"""
        xss_payloads = [
            '<script>alert("XSS")</script>',
            '<img src=x onerror=alert(1)>',
            '" onmouseover="alert(1)',
            "'><script>alert(1)</script>"
        ]
        
        vulnerabilities = []
        for payload in xss_payloads:
            try:
                test_url = self.build_test_url(url, param, payload)
                response = requests.get(test_url, timeout=5, verify=False)
                
                # Check if payload is reflected without encoding
                if payload in response.text:
                    vuln = {
                        'type': 'Cross-Site Scripting (XSS)',
                        'url': test_url,
                        'parameter': param,
                        'severity': 'high',
                        'tool': 'custom_xss_test',
                        'evidence': f'Payload reflected: {payload}',
                        'timestamp': datetime.now().isoformat()
                    }
                    vulnerabilities.append(vuln)
                    self.logger.info(f"Potential XSS found: {test_url}")
                    
            except Exception as e:
                self.logger.debug(f"XSS test failed: {e}")
        
        return vulnerabilities

    async def test_lfi_async(self, url, param):
        """Test for LFI vulnerabilities (async version)"""
        lfi_payloads = [
            '../../../../etc/passwd',
            '....//....//....//etc/passwd',
            '../../../../windows/win.ini'
        ]
        
        vulnerabilities = []
        for payload in lfi_payloads:
            try:
                test_url = self.build_test_url(url, param, payload)
                response = requests.get(test_url, timeout=5, verify=False)
                
                # Check for LFI indicators
                if 'root:x:0:0:' in response.text:
                    vuln = {
                        'type': 'Local File Inclusion (LFI)',
                        'url': test_url,
                        'parameter': param,
                        'severity': 'high',
                        'tool': 'custom_lfi_test',
                        'evidence': 'etc/passwd content found',
                        'timestamp': datetime.now().isoformat()
                    }
                    vulnerabilities.append(vuln)
                    self.logger.info(f"Potential LFI found: {test_url}")
                    break
                    
                elif '[boot loader]' in response.text:
                    vuln = {
                        'type': 'Local File Inclusion (LFI)',
                        'url': test_url,
                        'parameter': param,
                        'severity': 'high',
                        'tool': 'custom_lfi_test',
                        'evidence': 'Windows boot loader content found',
                        'timestamp': datetime.now().isoformat()
                    }
                    vulnerabilities.append(vuln)
                    self.logger.info(f"Potential LFI found: {test_url}")
                    break
                    
            except Exception as e:
                self.logger.debug(f"LFI test failed: {e}")
        
        return vulnerabilities

    def build_test_url(self, url, param, payload):
        """Build test URL with payload"""
        parsed = urlparse(url)
        query_dict = parse_qs(parsed.query)
        
        # Replace the parameter value with payload
        if param in query_dict:
            query_dict[param] = [payload]
        
        # Rebuild query string
        new_query = '&'.join([f"{k}={v[0]}" for k, v in query_dict.items()])
        
        # Rebuild URL
        new_url = urlunparse((
            parsed.scheme,
            parsed.netloc,
            parsed.path,
            parsed.params,
            new_query,
            parsed.fragment
        ))
        
        return new_url
    
    async def run_php_specific_tests_async(self, url: str) -> List[Dict]:
        """Run PHP-specific vulnerability tests (async version)"""
        findings = []
        
        # Get base URL without parameters
        base_url = url.split('?')[0]
        base_path = base_url.rstrip('/')
        
        php_test_paths = [
            '/phpinfo.php', '/info.php', '/test.php', '/debug.php',
            '/admin.php', '/config.php', '/dbconfig.php',
            '/backup/', '/uploads/', '/inc/', '/include/'
        ]
        
        for path in php_test_paths:
            test_url = f"{base_path}{path}"
            try:
                response = requests.get(test_url, timeout=3, verify=False)
                if response.status_code == 200:
                    # Check for phpinfo exposure
                    if 'phpinfo' in response.text.lower() and 'PHP Version' in response.text:
                        finding = {
                            'type': 'PHPInfo Exposure',
                            'url': test_url,
                            'severity': 'medium',
                            'confidence': 'high',
                            'tool': 'php_specific_test',
                            'evidence': 'PHPInfo configuration page exposed',
                            'description': 'PHPInfo page exposes sensitive server configuration',
                            'timestamp': datetime.now().isoformat()
                        }
                        findings.append(finding)
                        self.logger.info(f"PHPInfo exposure found: {test_url}")
                    
                    # Check for config file exposure
                    if any(keyword in response.text for keyword in 
                          ['DB_PASSWORD', 'mysql_connect', 'database_password', 'db_host']):
                        finding = {
                            'type': 'Config File Exposure',
                            'url': test_url,
                            'severity': 'high',
                            'confidence': 'medium',
                            'tool': 'php_specific_test',
                            'evidence': 'Database credentials found in response',
                            'description': 'Configuration file exposes sensitive credentials',
                            'timestamp': datetime.now().isoformat()
                        }
                        findings.append(finding)
                        self.logger.info(f"Config file exposure found: {test_url}")
                        
            except Exception as e:
                continue
        
        return findings
    
    async def run_custom_tests(self, target: Dict) -> List[Dict]:
        """Run custom tests based on target characteristics"""
        url = target['url']
        findings = []
        
        print(f"         Testing: {url[:60]}...")
        
        # Run enhanced nuclei scan with proper templates
        try:
            nuclei_findings = await self.run_nuclei_scan_async(url)
            findings.extend(nuclei_findings)
        except Exception as e:
            print(f"         Nuclei failed: {e}")
        
        # Run basic curl tests for SQLi and XSS
        if '?' in url:  # Only test URLs with parameters
            print("         Running basic security tests...")
            basic_findings = await self.run_basic_curl_tests(url)
            findings.extend(basic_findings)
        
        # Run SQLMap for high-priority SQLi targets
        if '?' in url and any(param in url.lower() for param in ['id=', 'artist=', 'user=', 'cat=']):
            print("         Running SQLMap...")
            sql_findings = await self.run_sqlmap_quick(url)
            findings.extend(sql_findings)
        
        # Run PHP-specific tests if applicable
        if self._is_php_target(url):
            print("         Running PHP-specific tests...")
            php_findings = await self.run_php_specific_tests_async(url)
            findings.extend(php_findings)
        
        print(f"         Found {len(findings)} potential issues")
        return findings

    # Backward compatibility methods
    async def run_parameter_tests(self, target_url, crawled_urls):
        """Alias for async method"""
        return await self.run_parameter_tests_async(target_url, crawled_urls)
    
    def run_nuclei_scan(self, target):
        """Sync wrapper for nuclei scan"""
        import asyncio
        return asyncio.run(self.run_nuclei_scan_async(target))