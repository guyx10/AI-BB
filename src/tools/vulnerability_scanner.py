#!/usr/bin/env python3
import asyncio
import subprocess
import json
from typing import List, Dict, Any

class VulnerabilityScanner:
    """Real vulnerability scanning using security tools"""
    
    async def run_command_with_timeout(self, cmd: str, timeout: int = 60) -> tuple:
        """Run a command with proper timeout handling"""
        try:
            process = await asyncio.create_subprocess_shell(
                cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            # Use asyncio.wait_for for timeout
            try:
                stdout, stderr = await asyncio.wait_for(process.communicate(), timeout=timeout)
                return process.returncode, stdout, stderr
            except asyncio.TimeoutError:
                print(f"         Command timeout: {cmd.split(' ')[0]}")
                process.terminate()
                return -1, None, None
                
        except Exception as e:
            print(f"         Command error: {e}")
            return -1, None, None
    
    async def run_nuclei(self, target: str) -> List[Dict]:
        """Run Nuclei vulnerability scanner"""
        try:
            # Try different nuclei commands
            nuclei_commands = [
                f"nuclei -u {target} -severity low,medium,high,critical -json -silent",
                f"nuclei -u {target} -t /home/th0th/nuclei-templates/ -severity low,medium,high,critical -json -silent",
                f"nuclei -u {target} -severity medium,high,critical -json -silent"
            ]
            
            all_findings = []
            
            for cmd in nuclei_commands:
                try:
                    print(f"         Running nuclei...")
                    returncode, stdout, stderr = await self.run_command_with_timeout(cmd, timeout=120)
                    
                    if returncode == 0 and stdout:
                        output = stdout.decode().strip()
                        if output:
                            for line in output.split('\n'):
                                if line.strip():
                                    try:
                                        finding = json.loads(line)
                                        all_findings.append(finding)
                                    except json.JSONDecodeError:
                                        continue
                    
                except Exception as e:
                    print(f"         Nuclei error: {e}")
                    continue
            
            return all_findings
            
        except Exception as e:
            print(f"❌ Nuclei error for {target}: {e}")
            return []
    
    async def run_sqlmap_quick(self, url: str) -> List[Dict]:
        """Run quick sqlmap scan with basic tests"""
        try:
            # Only test if URL has parameters
            if '?' not in url or '=' not in url:
                return []
                
            print(f"         Testing SQLi on: {url.split('?')[0]}...")
            
            # Very quick sqlmap scan - just test basic injection
            param = url.split('?')[1].split('=')[0] if '?' in url else 'id'
            cmd = f"sqlmap -u '{url}' --batch --level=1 --risk=1 --flush-session --time-sec=2 --threads=2"
            
            returncode, stdout, stderr = await self.run_command_with_timeout(cmd, timeout=30)
            
            if returncode == 0 and stdout:
                output = stdout.decode()
                
                # Parse sqlmap output for vulnerabilities
                if any(indicator in output for indicator in [
                    "sqlmap identified the following injection point",
                    "is vulnerable",
                    "injection point"
                ]):
                    return [{
                        'type': 'SQL Injection',
                        'url': url,
                        'tool': 'sqlmap',
                        'severity': 'high',
                        'confidence': 'high',
                        'evidence': 'SQL injection confirmed by sqlmap',
                        'parameter': param
                    }]
            
            return []
                
        except Exception as e:
            print(f"❌ SQLMap error for {url}: {e}")
            return []
    
    async def run_basic_curl_tests(self, url: str) -> List[Dict]:
        """Run basic curl-based security tests"""
        findings = []
        
        try:
            # Test for SQL error messages
            sql_payloads = ["'", "1' OR '1'='1", "1 AND 1=1"]
            for payload in sql_payloads:
                test_url = url.replace('=', f"={payload}", 1)
                cmd = f"curl -s -k '{test_url}' --connect-timeout 5"
                returncode, stdout, stderr = await self.run_command_with_timeout(cmd, timeout=10)
                
                if returncode == 0 and stdout:
                    response = stdout.decode().lower()
                    if any(error in response for error in ['sql', 'mysql', 'database', 'syntax', 'error']):
                        findings.append({
                            'type': 'SQL Injection Potential',
                            'url': url,
                            'tool': 'curl',
                            'severity': 'medium',
                            'confidence': 'low',
                            'evidence': f'SQL error message detected with payload: {payload}',
                            'parameter': url.split('?')[1].split('=')[0] if '?' in url else 'unknown'
                        })
                        break
            
            # Test for basic XSS reflection
            xss_payload = "<script>alert('xss')</script>"
            if '?' in url:
                test_url = url.replace('=', f"={xss_payload}", 1)
                cmd = f"curl -s -k '{test_url}' --connect-timeout 5"
                returncode, stdout, stderr = await self.run_command_with_timeout(cmd, timeout=10)
                
                if returncode == 0 and stdout:
                    response = stdout.decode()
                    if xss_payload in response:
                        findings.append({
                            'type': 'XSS Potential',
                            'url': url,
                            'tool': 'curl',
                            'severity': 'medium',
                            'confidence': 'low',
                            'evidence': 'XSS payload reflected in response',
                            'parameter': url.split('?')[1].split('=')[0] if '?' in url else 'unknown'
                        })
            
            return findings
            
        except Exception as e:
            print(f"❌ Curl test error for {url}: {e}")
            return []
    
    async def run_custom_tests(self, target: Dict) -> List[Dict]:
        """Run custom tests based on target characteristics"""
        url = target['url']
        findings = []
        
        print(f"         Testing: {url[:60]}...")
        
        # Run basic nuclei scan (if available)
        try:
            nuclei_findings = await self.run_nuclei(url)
            findings.extend(nuclei_findings)
        except Exception as e:
            print(f"         Nuclei failed: {e}")
        
        # Run basic curl tests for SQLi and XSS
        if '?' in url:  # Only test URLs with parameters
            print("         Running basic security tests...")
            basic_findings = await self.run_basic_curl_tests(url)
            findings.extend(basic_findings)
        
        # Run SQLMap for high-priority SQLi targets
        if '?' in url and any(param in url.lower() for param in ['id=', 'artist=', 'user=', 'cat=']):
            print("         Running SQLMap...")
            sql_findings = await self.run_sqlmap_quick(url)
            findings.extend(sql_findings)
        
        print(f"         Found {len(findings)} potential issues")
        return findings
